<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Single-Pass Downsampling</title>
</head>

<body>
    <div>
        <h3>Input</h3>
        <div>
            <h4>Downsample options</h4>
            <div>
                <fieldset>
                    <legend>Filter:</legend>
                    <div>
                        <input id="average" name="filter" type="radio" checked>
                        <label for="average">Average</label>
                    </div>
                    <div>
                        <input id="min" name="filter" type="radio">
                        <label for="min">Min</label>
                    </div>
                    <div>
                        <input id="max" name="filter" type="radio">
                        <label for="max">Max</label>
                    </div>
                    <div>
                        <input id="minmax" name="filter" type="radio">
                        <label for="minmax">MinMax</label>
                    </div>
                    <div>
                        <input id="custom" name="filter" type="radio">
                        <label for="custom">Custom</label>
                    </div>
                </fieldset>
                <div>
                    <label for="customFilterCode">Custom filter code</label>
                    <div>
                        <textarea id="customFilterCode" type="text" cols="120" rows="1">fn spd_reduce_4(v0: vec4<SPDFloat>, v1: vec4<SPDFloat>, v2: vec4<SPDFloat>, v3: vec4<SPDFloat>) -> vec4<SPDFloat> { return v0; }</textarea>
                    </div>
                </div>
                <div>
                    <h5>Region</h5>
                    <div>
                        <label for="offsetX">offset x</label>
                        <input id="offsetX" type="number" step="1" min="0" value="0">
                    </div>
                    <div>
                        <label for="offsetY">offset y</label>
                        <input id="offsetY" type="number" step="1" min="0" value="0">
                    </div>
                    <div>
                        <label for="useRoiSize">Use region size defined below</label>
                        <input id="useRoiSize" type="checkbox">
                    </div>
                    <div>
                        <label for="roiWidth">width</label>
                        <input id="roiWidth" type="number" step="1" min="0" value="0">
                    </div>
                    <div>
                        <label for="roiHeight">height</label>
                        <input id="roiHeight" type="number" step="1" min="0" value="0">
                    </div>
                </div>
                <div>
                    <h5>Misc</h5>
                    <div>
                        <label for="intoTarget">Into separate target</label>
                        <input id="intoTarget" type="checkbox">
                    </div>
                    <div>
                        <label for="halfPrecision">Use half precision</label>
                        <input id="halfPrecision" type="checkbox">
                    </div>
                </div>
            </div>
        </div>
        <div>
            <h4>Upload texture</h4>
            <input id="texture" type="file" accept="image/*">
        </div>
        <div>
            <h4>Checkerboard</h4>
            <div>
                <label for="checkerboardSize">Size</label>
                <input id="checkerboardSize" type="number" value="512" step="1" min="32", max="512">
            </div>
            <div>
                <label for="checkerboardNumChannels">Num. channels</label>
                <input id="checkerboardNumChannels" type="number" value="4" step="1" min="1", max="4">
            </div>
            <div>
                <label for="checkerboardNumArrayLayers">Num. array layers</label>
                <input id="checkerboardNumArrayLayers" type="number" value="16" step="1" min="1", max="16">
            </div>
            <div>
                <input id="generateCheckerboardButton" type="button" value="Generate Checkerboard">
            </div>
        </div>
    </div>
    <div>
        <h3>Display options</h4>
        <div>
            Mip Level
            <input id="mipLevelSlider" type="range" min="0" max="0" value="0" oninput="this.nextElementSibling.value = this.value">
            <output>0</output>
        </div>
        <div>
            Array Layer
            <input id="arrayLayerSlider" type="range" min="0" max="0" value="0" oninput="this.nextElementSibling.value = this.value">
            <output>0</output>
        </div>
    </div>
    <canvas></canvas>
    <script type="module">
        import { WebGPUSinglePassDownsampler, maxMipLevelCount } from '../dist/index.js';
        
        function makeCheckerboardTextureData(size, numChannels, tileSize = 16, offset = 0) {
            const data = new Float32Array(size * size * numChannels);
            for (let i = 0; i < size * size; ++i) {
                const x = (offset + i) % size;
                const y = Math.trunc(i / size);
                const v = (Math.trunc(x / tileSize) + Math.trunc(y / tileSize)) % 2;
                for (let c = 0; c < numChannels; ++c) {
                    data[i * numChannels + c] = c === 3 ? 1.0 : v;
                }
            }
            return data;
        }

        function makeCheckerboardTexture(device, size, numChannels, arrayLayers = 1, tileSize = 16) {
            const texture = device.createTexture({
                format: `${['r', 'rg', 'rgb', 'rgba'][numChannels - 1]}32float`,
                size: [size, size, arrayLayers],
                mipLevelCount: maxMipLevelCount(size),
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST,
            });
            for (let i = 0; i < arrayLayers; ++i) {
                device.queue.writeTexture(
                    { texture, origin: [0, 0, i] },
                    makeCheckerboardTextureData(size, numChannels, tileSize, i),
                    { bytesPerRow: size * numChannels * 4, rowsPerImage: size, },
                    [size, size],
                );
            }
            return texture;
        }

        async function main() {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice({requiredLimits: WebGPUSinglePassDownsampler.setPreferredLimits({}, adapter), requiredFeatures: adapter.features.has('shader-f16') ? ['shader-f16'] : []});

            const canvas = document.querySelector('canvas');
            const context = canvas.getContext('webgpu');
            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
            });

            const module = device.createShaderModule({
                code: `
                struct Config {
                    mip: u32,
                    array_layer: u32,
                }
                
                @group(0) @binding(0) var texture: texture_2d_array<f32>;
                @group(0) @binding(1) var<uniform> config: Config;
                    
                @vertex
                fn vertex(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
                    return vec4(vec2(f32((vertex_index << 1) & 2), f32(vertex_index & 2)) * 2 - 1, 0, 1);
                }
                
                @fragment
                fn fragment(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
                    let texture_size = textureDimensions(texture, config.mip);
                    let texture_coords = vec2<u32>(floor(coord.xy));
                    if texture_coords.x < texture_size.x && texture_coords.y < texture_size.y {
                        return vec4(textureLoad(texture, vec2<i32>(floor(coord.xy)), config.array_layer, config.mip).rgb, 1.0);
                    } else {
                        return vec4(0.0, 0.0, 0.0, 1.0);
                    }
                }
                `,
            });
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module,
                    entryPoint: 'vertex',
                },
                fragment: {
                    module,
                    entryPoint: 'fragment',
                    targets: [{ format: presentationFormat }],
                },
            });

            const downsampler = new WebGPUSinglePassDownsampler();

            const buffer = device.createBuffer({
                size: 8,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            
            let bindGroup = undefined;
            const render = (mip = 0, arrayLayer = 0) => {
                if (bindGroup) {
                    device.queue.writeBuffer(buffer, 0, new Uint32Array([mip, arrayLayer]));
                    
                    const encoder = device.createCommandEncoder();

                    const pass = encoder.beginRenderPass({
                        colorAttachments: [{
                            view: context.getCurrentTexture().createView(),
                            clearValue: [0,0,0,0],
                            loadOp: 'clear',
                            storeOp: 'store',
                        }],
                    });
                    pass.setPipeline(pipeline);
                    pass.setBindGroup(0, bindGroup);
                    pass.draw(3);
                    pass.end();

                    device.queue.submit([encoder.finish()]);
                }
            }

            const mipLevelSlider = document.getElementById('mipLevelSlider');
            const arrayLayerSlider = document.getElementById('arrayLayerSlider');
            mipLevelSlider.addEventListener('input', _ => render(mipLevelSlider.value, arrayLayerSlider.value));
            arrayLayerSlider.addEventListener('input', _ => render(mipLevelSlider.value, arrayLayerSlider.value));

            const filterRadio = Array.from(document.getElementsByName('filter'));
            const customFilterCode = document.getElementById('customFilterCode');

            const offsetX = document.getElementById('offsetX');
            const offsetY = document.getElementById('offsetY');
            const useRoiSize = document.getElementById('useRoiSize');
            const roiWidth = document.getElementById('roiWidth');
            const roiHeight = document.getElementById('roiHeight');

            const intoTarget = document.getElementById('intoTarget');
            const halfPrecision = document.getElementById('halfPrecision');

            const onNewTexture = texture => {
                if (filterRadio.filter(f => f.checked)[0].id === 'custom') {
                    downsampler.registerFilter('custom', customFilterCode.value);
                }
                const target = !intoTarget.checked ? texture : device.createTexture({
                    format: texture.format,
                    mipLevelCount: texture.mipLevelCount - 1,
                    size: [texture.width / 2, texture.height / 2, texture.depthOrArrayLayers],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
                });
                const config = {
                    filter: filterRadio.filter(f => f.checked)[0].id,
                    offset: [offsetX.value, offsetY.value],
                    size: useRoiSize.checked ? [roiWidth.value, roiHeight.value] : [texture.width, texture.height],
                    target,
                    precision: halfPrecision.checked ? 'f16' : 'f32',
                };
                if (!downsampler.generateMipmaps(device, texture, config)) {
                    console.warn(`could not downsample texture generated from ${textureUrl}`);
                    return;
                }

                canvas.width = target.width;
                canvas.height = target.height;

                bindGroup = device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        {
                            binding: 0,
                            resource: target.createView({
                                dimension: '2d-array',
                                mipLevelCount: target.mipLevelCount,
                                arrayLayerCount: target.depthOrArrayLayers,
                            }),
                        },
                        { binding: 1, resource: { buffer }},
                    ]
                });

                mipLevelSlider.max = target.mipLevelCount - 1;
                mipLevelSlider.value = 0;
                
                arrayLayerSlider.max = target.depthOrArrayLayers - 1;
                arrayLayerSlider.value = 0;

                render();
            }

            const textureInput = document.getElementById('texture');
            textureInput.addEventListener('change', _ => {
                if (textureInput.files.length) {
                    createImageBitmap(textureInput.files[0], { colorSpaceConversion: 'none' }).then(source => {
                        const texture = device.createTexture({
                            // todo: different formats?
                            format: 'rgba8unorm',
                            mipLevelCount: 1 + Math.log2(Math.max(source.width, source.height)),
                            size: [source.width, source.height],
                            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                        });
                        device.queue.copyExternalImageToTexture({ source, }, { texture }, { width: source.width, height: source.height });
                        onNewTexture(texture);
                    }).catch(console.error);
                }
            });

            const checkerboardSize = document.getElementById('checkerboardSize');
            const checkerboardNumChannels = document.getElementById('checkerboardNumChannels');
            const checkerboardNumArrayLayers = document.getElementById('checkerboardNumArrayLayers');
            const generateCheckerboardButton = document.getElementById('generateCheckerboardButton');
            generateCheckerboardButton.addEventListener('click', _ => {
                const numChannels = checkerboardNumChannels.value == 3 ? 4 : checkerboardNumChannels.value;
                const texture = makeCheckerboardTexture(device, checkerboardSize.value, numChannels, checkerboardNumArrayLayers.value);
                onNewTexture(texture);
            })
        }
        main();
    </script>
</body>
</html>